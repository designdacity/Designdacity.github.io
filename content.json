{"meta":{"title":"Designdacity's BLOG","subtitle":"LY leo","description":"Life is Struggle , To Be Coder Shit.","author":"Lei Y1","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-08-27T13:02:52.248Z","updated":"2017-08-27T13:02:52.248Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""}],"posts":[{"title":"Ajax学习笔记","slug":"2017/8/3","date":"2017-08-27T12:30:16.675Z","updated":"2017-08-23T12:33:55.054Z","comments":true,"path":"2017/08/27/2017/8/3/","link":"","permalink":"http://yoursite.com/2017/08/27/2017/8/3/","excerpt":"","text":"前后端分离的思路，所以都要通过Ajax来请求数据然后把数据渲染到页面上，一开始想过直接引用Jquery，但感觉就使用Jquery的Ajax函数，有点太浪费，所以就自己撸了一个Ajax函数。本文由浅入深，一步一步带你封装属于自己的Ajax库。 Ajax简介 Asynchronous Javascript And XML （异步的JavaScript和XML） 它并不是一种单一的技术，而是有机利用一系列交互式网页应用相关的技术所形成的结合体 Ajax是一种用于创建快速动态网页的技术。在前台与后台进行数据交换，Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，实现局部更新。 1、优点 页面无刷新，用户体验好。异步通信，更加快的响应能力。减少冗余请求，减轻了服务器负担。基于标准化的并被广泛支持的技术 2、应用场景场景 1. 数据验证 场景 2. 按需取数据 场景 3. 自动更新页面 … 说了这么多，接下来来点干货。 创建ajax的步骤 Ajax的原理简单来说通过XMLHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。原生创建ajax可分为以下四步 1、创建XMLHttpRequest对象123456789function createRequest ()&#123; if (window.XMLHttpRequest) &#123; //IE6以上 xhr = new XMLHttpRequest(); &#125; else &#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; return xhr;&#125; 2、准备请求1xhr.open(method,url,async); 第一个参数表示请求类型的字符串，其值可以是GET或者POST GET请求：1xhr.open(\"GET\",demo.php?name=hzzly&amp;age=21,true); POST请求：1xhr.open(\"POST\",demo.php,true); 第二个参数是要作为请求发送目标的URL。 第三个参数是true或false，表示请求是以异步还是同步的模式发出。（默认为true，一般不建议为false） 3、发送请求1xhr.send(); GET请求：12xhr.open(\"GET\",demo.php?name=hzzly&amp;age=21,true);xhr.send(); POST请求:123xhr.open(\"POST\",demo.php,true);xhr.setRequestHeder(\"Content-Type\",\"application/x-www-form-urlencoded;charset=UTF-8\");xhr.send(param) 4、处理响应12345xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; console.log(xhr.responseText); &#125;&#125; onreadystatechange：当处理过程发生变化的时候执行下面的函数 readyState：ajax处理过程 0：请求未初始化（还没有调用 open()） 1：请求已经建立，但是还没有发送（还没有调用 send()） 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头） 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成 4：响应已完成；您可以获取并使用服务器的响应了 status属性: 200: “OK” 404: 未找到页面 responseText：获得字符串形式的响应数据，可以用JSON.parse(xhr.responseText)转化为JSON对象 封装例子1.get请求函数12345678910111213141516171819202122232425262728293031323334353637383940/** * 一个简单的get请求 * @param &#123;String&#125; url 请求地址,文件名 * @param &#123;Function&#125; fnSucc 请求成功时执行的函数 * @param &#123;Function&#125; fnFaild 请求失败执行的函数 */function Get(url, fnSucc, fnFaild) &#123; //1.创建ajax对象 var xhr = null; /** * 此处必须需要使用window.的方式,表示为window对象的一个属性.不存在时值为undefined. * 进入else若直接使用XMLHttpRequest在不支持的情况下会报错 **/ if (window.XMLHttpRequest) &#123; //IE6以上 xhr = new XMLHttpRequest(); &#125; else &#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; //2.连接服务器 //open(方法,url,是否异步) xhr.open(\"GET\", url, true); //3.发送请求 xhr.send(); //4.接收返回 //OnRedayStateChange事件 xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; //alert(\"成功\" + xhr.responseText); fnSucc(xhr.responseText); &#125; else &#123; //alert(\"服务器响应失败!\"); if (fnFaild) &#123; fnFaild(); &#125; &#125; &#125; &#125;;&#125; 2.get与post结合的请求函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * AJAX函数封装 * @param &#123;string&#125; url 请求地址（必须） * @param &#123;object&#125; options 发送请求的选项参数 * @config &#123;string&#125; [options.type] 请求发送的类型。默认为GET。 * @config &#123;Object&#125; [options.data] 需要发送的数据。 * @config &#123;Function&#125; [options.onsuccess] 请求成功时触发。（必须） * @config &#123;Function&#125; [options.onfail] 请求失败时触发。 */function AJAX(url, options) &#123; //1.创建ajax对象 var xhr = null; /** * 此处必须需要使用window.的方式,表示为window对象的一个属性.不存在时值为undefined,进入else * 若直接使用XMLHttpRequest,在不支持的情况下会报错 **/ if (window.XMLHttpRequest) &#123; //IE6以上 xhr = new XMLHttpRequest(); &#125; else &#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; //2.连接服务器 //open(方法,url,是否异步) var param = \"\"; //请求参数。 //只有data存在，且为对象使才执行 var data = options.data ? options.data : -1; //缓存data if (typeof (data) === \"object\") &#123; for (var key in data) &#123; //请求参数拼接 if (data.hasOwnProperty(key)) &#123; param += `$&#123;key&#125;=$&#123;data[key]&#125;&amp;`; &#125; &#125; param.replace(/&amp;$/, \"\"); &#125; else &#123; param = \"timestamp=\" + new Date().getTime(); &#125; //3.发送请求 var type = options.type ? options.type.toUpperCase() : \"GET\"; if (type === \"GET\") &#123; xhr.open(\"GET\", `$&#123;url&#125;?$&#123;param&#125;`, true); xhr.send(); &#125; else &#123; xhr.open(\"POST\", url, true); xhr.setRequestHeder(\"Content-Type\",\"application/x-www-form-urlencoded;charset=UTF-8\"); xhr.send(param); &#125; //4.接收返回 //OnRedayStateChange事件 xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; //请求成功。形参为获取到的字符串形式的响应数据 options.onsuccess(xhr.responseText); &#125; else &#123; //先判断是否存在请求失败函数 //存在时，形参为XMLHttpRequest对象，便于进行错误进行处理 if (options.onfail) &#123; options.onfail(xhr); &#125; &#125; &#125; &#125;;&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/categories/Javascript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"JavaScript通过原型设计一个事件对象","slug":"2017/8/2","date":"2017-08-27T12:30:16.671Z","updated":"2017-08-20T15:19:00.402Z","comments":true,"path":"2017/08/27/2017/8/2/","link":"","permalink":"http://yoursite.com/2017/08/27/2017/8/2/","excerpt":"","text":"JavaScript通过原型设计一个事件对象实现以下功能：1. 添加监听者 2. 移除监听者 3. 清空监听者 4. 发起事件信号 设计思路如下：定义一个对象，包含一个实例成员listeners，用于记录所有的监听者 为对象的原型增加，新增、删除、清空和执行四个成员 具体代码可以参见下面示例 代码实现 hljs.initHighlightingOnLoad(); 123456789101112131415161718192021222324252627282930313233343536373839404142function myEvent()&#123; this.listeners = []; //监听者列表&#125;//添加一个监听者myEvent.prototype.addListener = function(fn)&#123; this.listeners.push(fn);&#125;;//除移一个监听者myEvent.prototype.removeListener = function(fn)&#123; var index = this.listeners.indexOf(fn); this.listeners.splice(index,1);&#125;;//清除所有监听者myEvent.prototype.clearListeners = function()&#123; this.listeners = [];&#125;;//发出执行信号，并告之所有监听者myEvent.prototype.raise = function(e)&#123; var l = this.listeners.length; for(var i = 0; i &lt; l; i++)&#123; this.listeners[i](e); //执行所有监听方法 &#125;&#125;;var me = new myEvent();//事件fun1function fun1(e) &#123; console.log('fun1: ' + e);&#125;//事件fun2function fun2(e) &#123; console.log('fun2: ' + e);&#125;//调用相关方法进行测试me.addListener(fun1);me.addListener(fun2);me.removeListener(fun1)//me.clearListeners();me.raise(\"a\");","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/categories/Javascript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"prototype","slug":"prototype","permalink":"http://yoursite.com/tags/prototype/"}]},{"title":"JavaScript编码规范指南","slug":"2017/8/1","date":"2017-08-27T12:30:16.650Z","updated":"2017-08-20T11:54:46.801Z","comments":true,"path":"2017/08/27/2017/8/1/","link":"","permalink":"http://yoursite.com/2017/08/27/2017/8/1/","excerpt":"","text":"=====================常用的一些javascript规范 数据类型原始类型(Primitives)：当你给一个原始类型赋值时，返回的是这个值的本身。 string number boolean null undefined 123456789101112131415161718 var foo = 1, bar = foo; bar = 9; console.log(foo, bar); // =&gt; 1, 9``` **对象类型**:当你给一个对象类型赋值时，返回的是这个值的引用。* object* array* function```javascriptvar foo = [1, 2], bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 对象 新建一个对象的语法 12345//不推荐var item = new Object();//推荐var item = &#123;&#125;; 不要使用保留字作为键值，否则在IE8下面会出现问题(详情)。 1234567891011//不推荐var superman = &#123; default: &#123; clark: 'kent'&#125;, private: true&#125;;//推荐var superman =&#123; defaults: &#123; clark: 'kent'&#125;, hidden: true&#125;; 使用可读性强的同义词代替保留字 1234567891011121314//不推荐var superman = &#123; class: 'alien'&#125;;//不推荐var superman = &#123; klass: 'alien'&#125;;//推荐var superman = &#123; type: 'alien'&#125;; 数组 新建一个数组的语法 12345//不推荐var items = new Array();//推荐var items = []; 如果你不知道数组的长度可以使用push将元素加入。 1234567var someStack = [];//不推荐someStack[someStack.length] = 'something';//推荐someStack.push('something'); 当你需要复制一个数组的时候使用slice。jsPerf 1234567891011var len = items.length, itemsCopy = [], i;//不推荐for (i = 0; i &lt; len; i++)&#123; itemsCopy[i] = items[i];&#125;//推荐itemsCopy = items.slice(); 用slice转换伪数组对象到数组 1234function trigger() &#123; var args = Array.prototype.slice.call(arguments); ...&#125; String类型 使用单引号’’ 1234567891011//不推荐var name = \"Bob Parr\";//推荐var name = 'Bob Parr';//不推荐var fullName - \"Bob \" + this.lastName;//推荐var fullName = 'Bob ' + this.lastName; 当字符串长度超过80个时，应该通过字符串连接多行显示。 注意：过度使用字符串连接将会影响性能。jsPerf&amp;Discussion 123456789101112131415161718//不推荐var errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';//不推荐var errorMessage = 'This is a super long error that \\was thrown because of Batman. \\When you stop to think about \\how Batman had anything to do \\with this, you would get nowhere \\fast.';//推荐var errorMessage = 'This is a super long error that ' + 'was thrown because of Batman.' + 'When you stop to think about ' + 'how Batman had anything to do ' + 'with this, you would get nowhere ' + 'fast.'; 当程序建立一个字符串时， 使用join代替字符串连接。特别是在IE下：jsPerf 1234567891011121314151617181920212223242526272829303132333435363738var items, messages, length, i;messages = [&#123; state: 'success', message: 'This one worked.'&#125;,&#123; state: 'success', message: 'This one worked as well.'&#125;,&#123; state: 'error', message: 'This one did not work.'&#125;];length = messages.length;// 不推荐function inbox(messages) &#123; items = '&lt;ul&gt;'; for (i = 0; i &lt; length; i++) &#123; items += '&lt;li&gt;' + messages[i].message + '&lt;/li&gt;'; &#125; return items + '&lt;/ul&gt;';&#125;// 推荐function inbox(messages) &#123; items = []; for (i = 0; i &lt; length; i++) &#123; items[i] = messages[i].message; &#125; return '&lt;ul&gt;&lt;li&gt;' + items.join('&lt;/li&gt;&lt;li&gt;') + '&lt;/li&gt;&lt;/ul&gt;';&#125; 函数 函数表达式： 1234567891011121314// 匿名函数表达式var anonymous = function()&#123; return true;&#125;// 命名函数表达式var named = function named() &#123; return true;&#125;;// 立即执行的函数表达式（IIFE）(function()&#123; console.log('Welcome to the Internet. Please follow me.');&#125;)(); 不要将函数声明放在如if/while循环或其他任何语句中。但可以用函数表达式来替代函数声明这么做。一些浏览器可能的确可以在语句中使用函数声明。但是在解析方面的处理各不相同，各种浏览器下兼容性很不好。 注意: ECMA-262定义了一系列的语句，但是函数声明并没有被归类为真正的语句。关于这点可查看ECMA-262的文档12345678910111213//不推荐if (currentUser)&#123; function test() &#123; console.log('Nope.'); &#125;&#125;//推荐if (currentUser)&#123; var test = function test() &#123; console.log('Yup.'); &#125;&#125; arguments 不能作为一个参数的名字， 因为这会覆盖每一个函数内的arguments对象。123456789//不推荐function nope(name, options, arguments) &#123; // ...stuff...&#125;//推荐function yup(name, options, args) &#123; // ...stuff...&#125; 属性 访问一个属性时，使用点的形式取值。 12345678910var luke = &#123; jedi: true, age: 28&#125;;// 不推荐var isJedi = luke['jedi'];// 推荐var isJedi = luke.jedi; 需要一个变量访问一个属性时，使用“[]”来取值。 12345678910var luke = &#123; jedi: true, age: 28&#125;;function getProp(prop) &#123; return luke[prop];&#125;var isJedi = getProp('jedi'); 变量 总是使用 var 来定义变量。如果不这么做将定义一个全局变量出来。我们希望避免全局命名空间的污染。 12345// 不推荐superPower = new SuperPower();// 推荐var superPower = new SuperPower(); 使用一个var 声明多个变量，并且每声明一个变量就换一行。 123456789// 不推荐var items = getItems();var goSportsTeam = true;var dragonball = 'z';// 推荐var items = getItems(), goSportsTeam = true, dragonball = 'z'; 声明多个变量时，把不赋值的变量放在后面。这样做是有好处的，如果日后你想给未赋值变量赋值的时候，可能要引用到上面已经赋值的变量。 1234567891011121314151617// 不推荐var i, len, dragonball, items = getItems(), goSportsTeam = true;// 不推荐var i, items = getItems(), dragonball, goSportsTeam = true, len;// 推荐var items = getItems(), goSportsTeam = true, dragonball, length, i; 在一个作用域的顶部给一个变量赋值。这样有助于避开，变量声明和声明提前的分配问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 不推荐function() &#123; test(); console.log('doing stuff..'); //..other stuff.. var name = getName(); if (name === 'test') &#123; return false; &#125; return name;&#125;// 推荐function() &#123; var name = getName(); test(); console.log('doing stuff..'); //..other stuff.. if (name === 'test') &#123; return false; &#125; return name;&#125;// 不推荐function() &#123; var name = getName(); if (!arguments.length) &#123; return false; &#125; return true;&#125;// 推荐function() &#123; if (!arguments.length) &#123; return false; &#125; var name = getName(); return true;&#125; 声明提前 不管你在何处给一个变量声明或赋值，javascript解析器都会事先在作用域的顶端做声明提前（Hoisting）。 12345678910111213141516171819// 我们知道下面将不能正常运行（假设没有全局变量）function example() &#123; console.log(notDefined); // =&gt; 抛出一个引用错误&#125;// 在引用这个变量之后，给这个变量赋值将不会抛异常，这是因为javascript解析器有声明提前。// 注意：赋的“true”值，不会被提前。function example() &#123; console.log(declaredButNotAssigned); // =&gt; undefined var declaredButNotAssigned = true;&#125;// javascript解析器,会在作用域的顶部提前声明变量。// 用代码描述出来，其实就等同于下面这种情况。function example() &#123; var declaredButNotAssigned; console.log(declaredButNotAssigned); // =&gt; undefined declaredButNotAssigned = true;&#125; 匿名函数表达式将该变量名做了提前声明，没有给该变量赋值函数。 123456789function example() &#123; console.log(anonymous); // =&gt; undefined anonymous(); // =&gt; 抛出异常，anonymous 不是一个函数 var anonymous = function() &#123; console.log('anonymous function expression'); &#125;;&#125; 和匿名一样，有名函数表达式将该变量名做了提前声明，没有给该变量赋值函数名和函数体。 12345678910111213141516171819202122function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; 抛出异常， named 不是一个函数 superPower(); // =&gt; 抛出异常， superPower 没定义 var named = function superPower() &#123; console.log('Flying'); &#125;;&#125;// 把函数名改成和变量名一样，也得出同样的结果。function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; 抛出异常， named 不是一个函数 var named = function named() &#123; console.log('named'); &#125;;&#125; 函数声明会将函数名和函数体声明提前。 1234567function example() &#123; superPower(); // =&gt; Flying function superPower() &#123; console.log('Flying'); &#125;&#125; 更多信息请参照Ben Cherry 的JavaScript Scoping &amp; Hoisting 条件表达式与等式使用 === 和 !== 代替== 和 != 条件表达式 会通过 ToBoolean 来进行强制转化，而且遵循以下的规则： 对象被转化为true Undefined被转化为false Null被转化为false 布尔值被转化为相应的布尔值 数字当值为+0,-0或NaN时转化为false，其他的转化为true Strings类型如果为空时转化为false,否则转化为true1234if ([0]) &#123; // true // 因为数组是对象，对象会被转化为 true&#125; 使用快捷方式 12345678910111213141516171819// 不推荐if (name !== '') &#123; // ...stuff...&#125;// 推荐if (name) &#123; // ...stuff...&#125;// 不推荐if (collection.length &gt; 0) &#123; // ...stuff...&#125;// 推荐if (collection.length) &#123; // ...stuff...&#125; 更多的信息 请看Angus Croll的 Truth Equality and JavaScript 块 给多行的块，使用大括号12345678910111213141516171819// 不推荐if (test) return false;// 推荐if (test) return false;// 推荐if (test) &#123; return false;&#125;// 不推荐function() &#123; return false; &#125;// 推荐function() &#123; return false;&#125; 注释 使用 /**...*/ 进行多行注释。注释要包括描述、指定类型、参数值和返回值。 12345678910111213141516171819202122232425262728// 不推荐// make() returns a new element// based on the passed in tag name//// @param &lt;String&gt; tag// @return &lt;Element&gt; elementfunction make(tag) &#123; // ...stuff... return element;&#125;// 推荐/** * make() returns a new element * based on the passed in tag name * * @param &lt;String&gt; tag * @return &lt;Element&gt; element */function make(tag) &#123; // ...stuff... return element;&#125; 使用 // 进行单行注释。注释单独占一行，并写在需要注释对象的上面。在注释的上面留一个空行。 12345678910111213141516171819202122232425// 不推荐var active = true; // is current tab// 推荐// is current tabvar active = true;// 不推荐function getType() &#123; console.log('fetching type...'); // set the default type to 'no type' var type = this._type || 'no type'; return type;&#125;// 推荐function getType() &#123; console.log('fetching type...'); // set the default type to 'no type' var type = this._type || 'no type'; return type;&#125; 给你的代码加前缀，比如FIXME或TODO，这样有助于其他开发者可以迅速理解你指出的需要被处理的问题。如果想更清晰一点你还可以在后面加上描述，比如: FIXME -- need to figure this out或TODO -- need to implement. 使用 // FIXME: 去注释问题 1234567function Calculator() &#123; // FIXME: shouldn't use a global here total = 0; return this;&#125; 使用 // TODO: 来注释解决方法 1234567function Calculator() &#123; // TODO: total should be configurable by an options param this.total = 0; return this;&#125; 空格 将tab键设成2个空格 123456789101112131415// 不推荐function() &#123;∙∙∙∙var name;&#125;// 不推荐function() &#123;∙var name;&#125;// 推荐function() &#123;∙∙var name;&#125; 逗号/冒号/小括号后面留一个空格 123456789101112131415161718192021// 不推荐function test()&#123; console.log('test');&#125;// 推荐function test() &#123; console.log('test');&#125;// 不推荐dog.set('attr',&#123; age: '1 year', breed: 'Bernese Mountain Dog'&#125;);// 推荐dog.set('attr', &#123; age: '1 year', breed: 'Bernese Mountain Dog'&#125;); 在文件的最后留一个空行 12345678// 不推荐(function(global) &#123; // ...stuff...&#125;)(this);// 推荐(function(global) &#123; // ...stuff...&#125;)(this); 逗号 逗号不要前置12345678910111213141516171819202122232425// 不推荐var once , upon , aTime;// 推荐var once, upon, aTime;// 不推荐var hero = &#123; firstName: 'Bob' , lastName: 'Parr' , heroName: 'Mr. Incredible' , superPower: 'strength'&#125;;// 推荐var hero = &#123; firstName: 'Bob', lastName: 'Parr', heroName: 'Mr. Incredible', superPower: 'strength'&#125;; 最后一个元素不可以加逗号。这在IE6和IE7还有IE9的怪异模式下出错。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/categories/Javascript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"编码规范","slug":"编码规范","permalink":"http://yoursite.com/tags/编码规范/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-08-27T09:01:42.561Z","updated":"2017-08-27T08:11:48.569Z","comments":true,"path":"2017/08/27/hello-world/","link":"","permalink":"http://yoursite.com/2017/08/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}